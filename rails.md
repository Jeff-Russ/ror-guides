<div id="page"      style="display: none;"><!-- Rails --></div>
<div id='home-url'  style="display: none;"><!-- http://www.jeffruss.com --></div>
<div id='logo-url'  style="display: none;"><!-- https://s3.amazonaws.com/jeffruss/img/JR_20px_wide.png --></div>

<div class="catergory-menu" id='HowTo'  style="display: none;"><!--  --></div>
<div class="catergory-menu" id='Resume' style="display: none;"><!--  --></div>
<div class="catergory-menu" id='GitHub' style="display: none;"><!--  --></div>

<div class="page-menu" id='RubySheet' style="display: none;"><!--http://www.jeffruss.com/?docs=ruby-cheatsheet--></div>
<div class="page-menu" id='Boostrap' style="display: none;"><!--http://www.jeffruss.com/?docs=bootstrap--></div>



<!-- __________________________________________________________________ -->

# How-To: Ruby on Rails

--------------------------------------------------------------------------------

## SETUP APP

<div class="section" id='Setup'><!--#Setup--></div>

----------------------------------------------------------------------------

### 1. Generate the App

__Set up environment with specified ruby and rails versions:__

To check Ruby and rails version:

    $ ruby -v
    $ rails -v

__To install latest Ruby and Rails and create app__

    $ gem install rails
    $ rails new MySite # generate web app dir and files

__To reinistall Rails with specific version and create app:__

    $ gem uninstall rails
    $ gem uninstall railties
    $ gem install rails -v 4.1.0
    $ rails _4.1.0_ new MySite

Specifying the version number it only needed if you have more than one installed.
If you want mySQL locally, run: `$ rails new MySite -d mysql`



--------------------------------------------------------------------------------
### 2. Install Gem Add-Ons

Rails uses add-ons called Gems which you can specify in the file called Gemfile.
This file already has recommended Gems listed in it, ready to install with the
following command:

    $ cd <project/root/directory/>
    $ bundle update  # do this step only if the next one does not work alone
    $ bundle install --without production # has remembered option

This remembered option means the next time you run `bundle install` it will retain.
Beware that running things like `bundle update` `bundle install`and
`bundle exec` will work without `bundle` but `bundle` insures that you run the
version used by your app project! Therefore it's much safer to prepend with it.

If you want to verify what has been installed you can run

    $ gem list rails   to view only the rails gems
    $ gem list         to list all gems

__Customize Gemfile__

Take a look at the Gemfile you just installed from.

If you use a Gemfile that was not generated by your install it must show the
same rails version as the one you have intalled on your system. You can have
multiple versions intalled and the Gemfile with dictate which version your app
will use.

Typically version numbers in Gemfiles are given as ranges but for learning it's good
to have exact version numbers. This means removing all ~and >= from this file.

here is the complete Gemfile as used in a project running Rails 4.1.0:

    source 'https://rubygems.org'

    gem 'rails', '4.1.0' #  Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
    gem 'sqlite3', group: [:development, :test]    #  Use sqlite3 as db for Active Record

    # Use postgresql as the database for production
    group :production do
    gem 'pg'
    gem 'rails_12factor'
    end

    # See https://github.com/sstephenson/execjs#readme for more supported runtimes
    # gem 'therubyracer',platforms: :ruby

    # Turbolinks makes following links in your web application faster. Read more: https://github.com/rails/turbolinks
    # gem 'turbolinks'

    gem 'sass-rails', '4.0.3'           # Use SCSS for stylesheets
    gem 'bootstrap-sass', '3.3.1'       # Use bootstrap library for styles
    gem 'font-awesome-sass', '4.2.0'    # Use font awesome library for icons

    gem 'uglifier', '1.3.0'             # Compressor for JavaScript assets
    gem 'coffee-rails', '4.0.0'         # Use .js.coffee assets and views
    gem 'jquery-rails'                  # Use jquery as JavaScript library
    gem 'jbuilder', '2.0'               # Build JSON APIs with ease
    gem 'sdoc', '0.4.0', group: :doc    # bundle exec rake doc:rails generates the API under doc/api.
    gem 'spring', group: :development   # speeds up dev by keeping app running in the bg.

    gem 'devise', '3.4.1'               # Use devise for user auth
    # gem 'bcrypt', '3.1.7'             # Use ActiveModel has_secure_password

    gem 'stripe', '1.16.1'              # Use stripe for handling payments
    gem 'figaro', '1.0.0'               # Use figaro to hide secret keys

    gem 'paperclip', '4.2.1'            # Use paperclip for image uploads
    # gem 'aws-sdk-v1' # For Amazon's S3 service If using paperclip <= v4.3.1

    gem 'redcarpet', '~2.1.1'           # for markdown support
    gem 'coderay', '~1.0.7'             # for markdown support

The following secions take you through some of these additions one by one.

--------------------------------------------------------------------------------
### 3. Font Awesome Setup

Add this to Gemfile:

    # add font awesome library for icons
    gem 'font-awesome-sass'

Run this terminal command which will fetch the gem online and install it:

    $ bundle install

Add this to app/assets/stylesheets/application.css.scss:

    @import "font-awesome-sprockets";
    @import "font-awesome";

--------------------------------------------------------------------------------
### 4. Bootstrap Setup

Go to your Gemfile and add this anywhere logical and save the file:

    # adding bootstrap's gem
    gem 'bootstrap-sass'

Run this terminal command which will fetch the gem online and install it:

    $ bundle install

Look at the docs for bootstrap-sass on github. Find and rename this file using
git's command rather than the normal one which results in a delete operation:

    $ cd app/assets/stylesheets
    $ mv application.css application.css.scss

Renaming this file lets the preprocessor know we will add SASS syntax to CSS
Now we will add these two lines to the bottom and hit save:

    @import "bootstrap-sprockets";
    @import "bootstrap";

If you read the bootstrap docs you will see that you need a javascript plugin.
Go to the docs on github.com/twbs/bootstrap-sass and you will see
Require Bootstrap JS in app/assets/javascripts/application.js

Find that file and add below the line for jQuery:

    //= require bootstrap-sprockets

Without this, the site will adapt to some degree but not completely. For example,
if you have a navigation bar with a number of option they will compress into a menu
but the menu will not be functional without this inclusion.

--------------------------------------------------------------------------------
### 5. Launch Site Locally

Now let's launch the site privately:

    $ rails server -p 808                  # Do this for local machines
    $ bundle exec rails server -p $PORT -b $IP   # Do this for cloud9

You can grab the URL and open it anywhere else. When you are done coding you may
want to take it down by being in the terminal and hitting ctrl-c
If you ever need to know your IP address and/or your port you can...

    $ echo $IP
    $ echo $PORT

This shows a spash screen since we haven't created any pages yet. This works
fine to test locally but if we tried to deploy to the live web we would not get
this spash screen so we wouldn't be able to tell if the app was working or not.

Lets temporarily add some content so we'll be able to deploy to the live web
using Heroku. After we set up Heroku and launch the site we can delete this added
content. Here is how to create a temporary home page and keep in mind this is
not a normal way we would ever add content!

1. In the file app/controllers/application_controller.rb you will find a class
    called ApplicationController. Add to it this method:

        def hello
          render text: "hello, world!"
        end

    This method is also called an "action" and it usually corresponds to a page
    on your site. Now lets tell the router to fetch it.

2. In config/routes.rb add the following as the second line:

        root 'application#hello'

3. Now launch the page locally again with one of these commands :

        $ rails server -p 808                  # Do this for local machines
        $ bundle exec rails server -p $PORT -b $IP   # Do this for cloud9

--------------------------------------------------------------------------------

## SETUP GIT

--------------------------------------------------------------------------------
### 1. Setup Git Source Control

First make a Github or Bitbucket account and VERIFY YOUR EMAIL.

Make sure your email address below is the same as you used with your Github or Bitbucket
account. I don't think it matters if usernames match. When doing anything with git
always make sure you are at the project root. Do the following only once per computer:

    $ git config --global user.name "Your Name"
    $ git config --global user.email "your@email.com"
    $ git config --global push.default matching
    $ cat ~/.ssh/id_rsa.pub       # copy entire key.

Go to Github and click on settings for your profile. Click SSH keys and add key from above.
Now for the things done per-project...                   

Make a repository on Github. You'll probably want it to have the same name as your app.
Choose not to make a README.md. After you submit, on the next screen click SSH and copy.
Before we connect our local file to Github we need to have git setup locally:

    $ cd <project/root/directory/>
    $ git init     # this generates the git control files and folders

Rails uses .rdoc for readme files which is not what Github uses. Change the
extension:

    $ git mv README.rdoc README.md

Before we start tracking our code we want to ignore certain files that have
sensitive data, expecially if we have a public repo on Github. Even if the files
don't yet exist, adding the following to the hidden file .gitignore will prevent
them from ever being uploaded.

See [here](https://help.github.com/articles/ignoring-files) for more about ignoring files.

    # TODO Comment out if OK with secrets being uploaded to the repo
    config/initializers/secret_token.rb
    config/secrets.yml

    # Ignore application configuration
    /config/application.yml

If you find yourself ignoring temporary files generated by your text editor
or operating system, you probably want to add a global ignore instead:

    $ git config --global core.excludesfile '~/.gitignore_global'

Now lets add and commit the project locally.

    $ git add -A   # get ready to add added files and delete deleted ones
    $ git status   # to view everything that was added
    $ git commit -m "Initial commit"  # This commits everything locally

Next you get set the origin to be the version online. This mean two things: we connect
the local with online and we declare the online to be the "origin." The address
we type in below is the copied SSH not HTML. This means we don't have to keep logging on.

    ### always in project root directory!!
    $ git remote add origin git@github.com:yourusername/MySite.git # copied from SSH
    $ git remote                 # to verify. you should see origin
    $ git push origin master     # This uploads our prior commits to the online repo

Deleted files are not updated with `git add .` so if you want to update any
deleted files you should use git to remove them or run `git add -A`

--------------------------------------------------------------------------------
### 2. Git Routine Suggestions

**Your daily workflow routine**

To preview site on c9.io...

    $ bundle exec rails server-p $PORT -b $IP  ctrl-c to take down preview

Keep server running. Open new terminal tab...

    ### in project root directory:
    $ git status  # If you see changes that you want to commit
    $ git add -A  # add all and update deleted files (if needed)
    $ git status  # check if it was added
    $ git commit -m "YOUR MSG"  # local commit
    $ git push origin <branch>  # push to github

Consider the master branch to be the one that is completed and deployed.
It should always mirror what is currently deployed to the live web.

There is only one moment where it might now. Heroku (which we will use for
deployment) can only be updated from the master branch. Just before you deploy
you will have your updates on another "working branch" and not the master. Just
before you deploy you will merge those update to the master branch and then deploy
from there.

I recommend at least two other branches in addition to the master branch:

1. update - this is the candidate for the next update
2. revert - this is a backup of the master as a mirror of previous deployment

Here is how you create those:

    $ git checkout -b update # copies current (master) branch to a new one, locally
    $ git push origin update # uploads the new branch to Github (or whatever)
    $ git checkout -b revert # copies current (update) branch to a new one, locally
    $ git push origin revert # uploads the new branch to Github (or whatever)

You should not work off of the master branch. If you start to and haven't ran
any commands to save it you are in luck. You can switch to another branch and save
the changes there. Here is how you would save them to the update branch:

    $ git checkout update
    $ git add -A # add the changes to update branch
    $ git commit -m "YOUR MSG" # local commit
    $ git push origin update   # upload

If, instead, you made change that you just want to discard you can run this:

    $ git checkout --force # or -f


<div class="section jump" id='Heroku'><!--#Heroku--></div>

## SETUP HEROKU DEPLOY

--------------------------------------------------------------------------------
### 1. Gemfile Update

Heroku is well known in the Ruby community. It's the most popular Rails host.
They have very elegant hosting and deployment setup that we would all benefit in
emulating even if we aren't hosting on Heroku. We push our app to Heroku and it
provides it with a domain name for deployment.

1. These modifications were made to Gemfile for Heroku compatibility:

        gem 'sqlite3', group: [:development, :test]

        # Use postgresql as the database for production
        group :production do
          gem 'pg'
          gem 'rails_12factor'
        end

2. If you just added this, you need to run bundle install in project root directory:

        $ bundle install

------------------------------------------------------------------------------
### 2. Heroku Account

1. Make and account at heroku.com with the same email address you used with github.
2. Go to your email to complete the account creation.
3. Make sure email is verified with github
4. Go back to cloud9 terminal in project root directory:

        $ heroku login
        $ YOUREMAIL@gmail.com
        $ ******** (one cap, one non alpha-num)
        $ heroku keys:add
        $ Y
        $ heroku create

--------------------------------------------------------------------------------
### 3. Deploy to Heroku

Make sure you are on the master branch and all (stable) changes are merged in.

    $ git push heroku master

--------------------------------------------------------------------------------
### 4. Troubleshooting Heroku

This grabs the latest copy from Git and sends it to the URL
If you go to your URL later and it's not there, that's okay, heroku sleeps it.
If you want to customize your domain name instead of using the one generated by
heroku, google domain keroku. If you want to view your domains or run console:

    $ heroku domains
    $ heroku run console

If you have trouble depolying you may want to check out `$ heroku logs` You
may see that some database doesn't exist on the heroku version and in this case
you can create it.Run this command whenever you alter your database:

    $ heroku run rake db:migrate

If you have Rails assest to compile you will need to run this:

    $ rake assets:precompile RAILS_ENV=production

You can use the following command to reset the entire database. The command
will simply drop and create the database. Afterward, run db:migrate.

    $ heroku pg:reset DATABASE

Another way is to reset the db locally and then push it to Heroku:

    $ rake db:reset
    $ heroku db:push

This can be used to restart the app on Heroku if you are in the root directory
of your rails application

    $ heroku restart

--------------------------------------------------------------------------------
### 5. Public Repos and Heroku

Rails uses keys to authorize deployment which should not be shared publicly.
There is a filed called .gitignore found at the project root which lists files
not to be tracked by git. The problem we run into is that Heroku has you use git
to send up the code for deployment and that code will not include the key. There
are a few solution to this such as the figaro and heroku_secrets gems.

I find there is need for figaro, heroku\_secrets or any other gem. Secrets can be
organized into two files: config/intializers/secret\_token.rb sets the
secret\_key\_base environmental variable used in production. This file is created
manually and should be added to gitignore. The second file is config/secrets.yml
This file is also created manually and is NOT added to gitignore. It will set
secret\_key\_base used in production using the environmental variable created in
secret\_token.rb as well as setting secret\_key\_base for development and testing
using strings.

I also found no need to set the variables using Heroku CLI's heroku config:set
command. Heroku will get and store the key without storing it to a file in the
actual Rails app.

In summary you will have three keys: development, test and production. You can
generate these yourself with the command `rake secret`

__Added to .gitignore__

    config/initializers/secret_token.rb

__example config/initializers/secret_token.rb:__

    TheAppName::Application.config.secret_key_base = ''

Note that the app name will always begin with a capital letter even if you didn't
give it one when you generated it with `rails new`. The app's name is declared as
a module in `config/application.rb`. Insert a key between '' that you generate
with `rake secret`.

__example config/secrets.yml:__

Insert a keys between '' that you generated with `rake secret`. SECRET\_KEY\_BASE
will take the value set in the gitignored secret_token.rb file.

    development:
    secret_key_base: ''

    test:
    secret_key_base: ''

    production:
    secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>

--------------------------------------------------------------------------------
### 6. Renaming Heroku Apps

__From the Heroku Website__

    $ heroku apps:rename newname
     Renaming oldname to newname... done
     http://newname.herokuapp.com/ | git@herokuapp.com:newname.git
     Git remote heroku updated

Renaming an app will cause it to immediately become available at the new
subdomain (newname.herokuapp.com) and unavailable at the old name
(oldname.herokuapp.com). If you have custom domains configured that use these
subdomains, for example a CNAME record set up that references
oldname.herokuapp.com, then it will also need to be updated.

If you are using the CLI to rename an app from inside the Git checkout
directory, your remote will be updated automatically. If you rename from the
website or have other checkouts, such as those belonging to other developers,
these will need to be updated manually:

    $ git remote rm heroku
    $ heroku git:remote -a newname

<div class="section jump" id='Domains'><!--#Domains--></div>

## SETUP GOOGLE DOMAINS

-------------------------------------------------------------------------------
### 1. Google Domains with Heroku

Instead of having your domain be a subdomain of herokuapp.com you can purchase
your own domain and have it point to the Heroku app. One solution is to purchase
one from google domains which is what will be explored here. In this example we
have the app name MySite and the Heroku domain mysite.herokuapp.com.

1. Sign up for Google Domains and purchase 'mysite.com'
2. Go to the DNS page
3. Under "Synthetic records" type "www" and click add.
4. Under "Custom resource records" add "www CNAME 1h mysite.herokuapp.com."

Now go over to your Heroku dashboard

1. Click on your app then go to the settings tab
2. Under "Domains" click "Add domain" type "mysite.com" (NO WWW) and submit
3. Click "Add domain" again and type your google domain WITH www and submit

Now you're DONE! It may take a few hour to take effect. Google says it could
take 48 hours but for me it's usually in effect in a few minutes. Sometimes I'll
enter "1m" instead of "1h" but I'm not certain if that makes any difference

--------------------------------------------------------------------------------
### 2. Google Subdomains with Heroku

You may choose to use the single Google domain name for many different apps.
One solution is to have a main app at your Google domain and then create other
Heroku apps which all are subdomains of your main app. We can arrange this so
none of the URLs show "herokuapp" quite nicely.

Lets say we have the following rails apps with the corresponding heroku domains:

* mysite -mysite.herokuapp.com
* forum-forum.herokuapp.com
* blog -blog.herokuapp.com

If our Google domain is, for example, "http://www.mysite.com" we can create these:

* http://www.mysite.com
* http://forum.mysite.com
* http://blog.mysite.com

To this we go to "Custom resource records" at Google Domains and add these:

1. forum CNAME 1h mysite.herokuapp.com.
2. blog CNAME 1h mysite.herokuapp.com.

Now we need to tell Heroku about this. Go to the same place on the Heroku site,
we will be using "Add domain" twice more:

1. add "forum.mysite.com"
2. add "blog.mysite.com"


<div class="section jump" id='Basics'><!--#Basics--></div>

# RAILS BASICS

--------------------------------------------------------------------------------
## THE RAILS MVC

1. **THE REQUEST**

    During rails development, you will use the server rails comes with, called WEBrick
    to serve the pages to your own machine only and view them in your browser. This
    server is for development stages only although it function much like any other.

    The WEBrick server receives an HTTP request from the brower (client) and figures out
    what Rails app it is for based on the URL being requested. If the request is a GET
    request (user wants to SEE a page) then it uses the end part of the URL to determine
    what files in the Rails application are needed to serve it back.  
    <br>

2. **SERVER-SIDE PROCESSING**

    The WEBrick server contacts the routes.rb file which hopefully has registered
    what to do for the particular URL be requested. For each URL, Rails has a
    controller#action pair. Think of your site as if it is many folder which each
    folder containing one or more web pages. The folder is the controller and
    action is the page.

    In more concrete terms, a controller is a single source file containing a
    single Ruby class which has a number of methods in it. If the controller name
    is `home` then the file will be called `home_controller.rb` and the class will
    be called `HomeController`. This correspondence is more than a convention,
    it's a requirement. The controllers are found in `app/controllers`

    As for the `action` part of "controller#action" it usually has a matching
    `view` file found in `app/views/CONTROLLERNAME/`. If we got an HTTP GET
    request for `home#index` (which would probably be handling the URL
    `http://sitename.com/home/index`) The actual HTML for the page would be in
    `app/views/home/index.html.erb`. Note the additional `erb` "Embedded Ruby"
    extension. This means there is Ruby scattered throughout the file that will
    be rendered to more HTML before it's sent back.

    In addition to all this static stuff we might need to customize the page
    according to what user is viewing it, for example. We might have account
    information stored in the database and in this case we would talk to the
    database with what's called a `model`.
    <br>

    #### MVC - Model View Controller

    1. app/controllers/home_controller.rb

        Thi finds the appropriate files from the model and view.

    2. app/models/users.rb

        This is typically the processing part of your web page. It has access to
        the database that's stored on the server.

    3. app/views/index.html.erb

        This is basically and HTML file containing the interface of the page.  
    <br><br>

3. **THE RESPONSE**

    The model and view both return their data back to the controller, which then
    returns back to the WEBrick server, which finally send the response back to the
    client.  
    <br>

4. **CLIENT-SIDE PROCESSING**

    The response can contain Javascript, which runs in the browser.

--------------------------------------------------------------------------------

#### ADDING PAGES WITH GENERATE

--------------------------------------------------------------------------------
##### 1. Generating a Controller for Pages

We will create two pages, a home page and an about page. First need a controller to
handle the fetching of either view. Rails can generate this for us:

    $ rails generate controller pages

This generates the following:

    app/controllers/pages_controller.rb
    app/views/pages/
    app/helpers/pages_helper.rb
    app/test/helpers/pages_helper_test.rb
    app/assets/javascripts/pages.js.coffee
    app/assets/stylesheets/pages.css.scss

The first two items are most notable. `app/controllers/pages_controller.rb` defines
a single class called `PagesController` which inherits from `ApplicationController`
It is empty now but we will put a method (know as an "action" in the context of rails)
for each page in this class definition.

The second item is a directory and it is where we will put view files matching each
method-action we add to the `pages_controller` class.

--------------------------------------------------------------------------------
##### 2. Creating Home & About Views

1. **Adding a route to the HTTP request**  

    The config/routes.rb file has an entry for each possible HTTP request from the
    user and has a action specified for each request. We want the home page to be
    the root of the site, meaning `sitename.com\` without anything added to the end.
    The routes file specifies the acion notated as: `controller#action`. In our
    we will make a method-action in our `PagesContoller` class called `home`
    Add the following as the second line of config/routes.rb:

        root 'pages#home'

    The second line will be for our about page. If you want to view all routes:

        $ rake routes

2. **Adding actions to controller**

    Go to app/controllers/pages_controller.rb and the method-action for home.
    While we are here we might as well add one for about, even though we havn't routed it.

        def home
        end
        def about
        end

3. **Adding a view to the action**

    Right click on the app/view/pages/ and add new file home.html.erb. Note that
    "home" mathes the name of the method we just made. This view is automatically
    fetched when `pages#home` is called by the router.

        <h2>Home</h2>

4. **Adding the about page**

    We already have the action for the about page in our controller. We only lack
    the routing and the view. This is how the route is defined in config/routes.rb:

    This syntax will be explained in the future. Lets add the corresponding view
    in app/views/pages/. In that location, create `about.html.erb` and type this:

        <h2>About Us<h2>

--------------------------------------------------------------------------------
##### 3. The Quick Way

We created the controller and views separately but there is a way to do all of
this with one single command:

    $ rails generate controller pages home about

This creates the controller with the two methods stubbed out and creates the
two view files with some placemarker code.


<div class="section jump" id='Sendgrid'><!--#Sendgrid--></div>

# EMAIL WITH SENDGRID

-------------------------------------------------------------------------------
### 1. Setup Heroku

You have already done this step in the setup but in case you haven't:

1. These modifications are made to Gemfile for Heroku compatibility:

        gem 'sqlite3', group: [:development, :test]

        # Use postgresql as the database for production
        group :production do
            gem 'pg'
            gem 'rails_12factor'
        end

2. Now we need to go in to the web and grab all the files associates with the Gems

        ### in project root directory:  
        $ bundle install

**Setup Heroku account**

1. Make and account at heroku.com with the same email address you used with github.
2. Go to your email to complete the account creation.
3. Make sure email is verified with github
4. Go back to cloud9 terminal:

in project root directory:

    $ heroku login
    $ jeffreylynnruss@gmail.com
    $ ******** (one cap, one non alpha-num)
    $ heroku keys:add
    $ Y
    $ heroku create

--------------------------------------------------------------------------------
### 2. Setup Sendgrid

Heroku has an add-on called Sendgrid which enables your site to send emails.  

    $ heroku addons:create sendgrid:starter

This command won't work if you haven't set up with sendgrid. Follow the site
to enter your info. It may prompt you for your credit card info but don't worry,
it won't charge you unless you send out something like 400 emails in a day. Add
your card info at  https://heroku.com/verify.

After you have done this you just run the same command again. The command
enables sendgrid for this particular app over at heroku. It does not modify
your local project.

--------------------------------------------------------------------------------
### 3. Setup ActionMailer

**With this addition we have the final state of app/config/environment.rb**

    ActionMailer::Base.smtp_settings = {
      :address => 'smtp.sendgrid.net',
      :port => '587',
      :authentication => :plain,
      :user_name => ENV['SENDGRID_USERNAME'],
      :password => ENV['SENDGRID_PASSWORD'],
      :domain => 'heroku.com',
      :enable_startstls_auto => true
    }

Lets have the server send out an email to us when someone successfully contacts us.  
Create a new file in app/mailers called contact\_mailer.rb. This is where we will
set the desination email (which does not have to mirror the one registered with
sendgrid or anywhere!).

**This is the final state of mailers/contact_mailer.rb**

    class ContactMailer < ActionMailer::Base
      default to: 'example@example.com' # replace with your email address

      def contact_email(name, email, body)
         @name = name
         @email = email
         @body = body

         mail(from: email, subject: 'Contact Form Message')
      end
    end

This class inherits from the ActionMailer class in rails. The method contact_email
will have a corresponding view and provide to it the instance variables that fill
in the content of the email

Lets make the view. In app/views/ make a new folder called contact\_mailer/ and
a file inside it called contact\_email.html.erb  

**This it the final state of views/contact_mailer/contact_email.html.erb**

    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <p>You received a message from the site's contact form, from <%= "#{ @name }, #{ @email }." %></p>
        <p><%= @body %></p>
      </body>
    </html>

The instance variable above match those in the ContactMailer class. Now all we
need to do it pass in the proper arguments.

__Explanation:__

We have just created a class called ContactMailer which extents the ActionMailer
class defined in Rails. It has a method called contact\_email which, together with
it's view, will be used to form the email. To actually send an email we will have
a line of code in another controller looking like this:

    ContactMailer.contact_email(name, email, body).deliver

--------------------------------------------------------------------------------
### 4. Contacts Model and Controller

Each time someone fills out the form to send us an email we will save it to our
database before sending it to ourselves. We will have a controller called contacts
which will have the URL for the form as well as a URL which takes the form
submission, stores it to the DB with a model called Contact, and sends it. Lets
create the model, controller and views.

    $ rails generate model Contact name:string email:string comments:text
    $ rails generate controller contacts

Now in routes.rb

    resources :contacts

This makes the application aware of a number of URL patterns. You can view
these in the console with `bundle exec rake routes`. Applications use what is
called CRUD (Create Read Update Delete) to allow the user or app to manipulate
data on the server. Rails specifically uses the paradym know as REST
(Representational State Transfer) to represent the four verbs:

    Create  Read    Update  Delete     -> CRUD   

    POST    GET     PUT     DELETE     -  Rails has these corresponding verbs  
                    PATCH

In a very real sense, these verbs represent the different kinds of HTTP requests.

You will see these verbs in the routes we have generated. GET will be the form
the user fills out and it will have a view at the URL /contacts/new which uses
app/view/contacts/new.html.erb.

Before we make the view file we need to have the action for it added to it's
controller. Make the contents of app/controllers/contacts\_controller.rb be:

    class ContactsController < ApplicationController
      def new
         @contact = Contact.new
      end
    end

--------------------------------------------------------------------------------
### 5. Form to Send Email

1. **Create a Basic View for the Form**

    Now lets put some Ruby + HTML code in our views/contacts/new.html.erb to create
    form fields. As you may remember, @contact is a single, empty database record.
    We will use the `form_for` Rails helper to access each field of the record.

        <%= form_for @contact do |f| %>
            <%= f.label :name %>
            <%= f.text_field :name %>

            <%= f.label :email %>
            <%= f.email_field :email %>

            <%= f.label :comments %>
            <%= f.text_area :comments  %>

            <%= f.submit 'Submit'  %>
        <% end %>

### 6. Sending the Email

At this point the submit button doesn't do anything. Go to your new.html.erb view.
If you inspect the HTML that it put to the browser you will see that the entire
form is inside of an HTML \<form\> element.

    <form accept-character-set"UTF-8" action="/contacts" class="new_contact" id="new_contact" method="post">

This shows that when the submit button is clicked a POST request is sent to
the /contacts. We are at url /contacts/new but what's at /contacts?
If we go there we get an error. Rails has automatically determined that when the
form it submitted it goes to /contacts. We get an error because it's missing code.

If you $ bundle exec rake routes you will see one that says GET and one that says
POST, both of which are associated to the URI pattern /contacts. The two have
different methods associated with them, with GET being assoicated with
contacts#index and POST being associated with contacts#create.

The actual contents of the form get sent over to the /contacts url via a

**"query string parameter"**  

All that means is that the actual url is custom and looks something like
thesite.com/contacts?name=test&email=test& etc...
Everything after the ? is the query string parameter.

The action that takes the post request is called create and it should be defined
in the contacts controller. In addition to this method we also need a method used
by rails for security. It's called contact_params and it is used by Rails to
whitelist the query string parameters to only be the ones we have defined.

Here is the final state of app/controller/contacts_controller.rb

    class ContactsController < ApplicationController
      def new
         @contact = Contact.new
      end

      def create
         @contact = Contact.new(contact_params)

         if @contact.save
            name = params[:contact][:name]
            email = params[:contact][:email]
            body = params[:contact][:comments]

            ContactMailer.contact_email(name, email, body).deliver

            flash[:success] = 'Message sent.'
            redirect_to new_contact_path
         else
            flash[:danger] = 'Error occured, message has not been sent.'
            redirect_to new_contact_path
         end
      end

      private
         def contact_params
            params.require(:contact).permit(:name, :email, :comments)
         end
    end

contact\_params is the query string parameter. We define contact\_params using the
method you see above which you should learn about. It falls under what rails calls
"strong parameters" which are whitelisted for security reasons. This is new in
Rails 4.

We want to send the email in the if statement block before the flash message.

    if @contact.save
        name = params[:contact][:name]
        email = params[:contact][:email]
        body = params[:contact][:comments]

        ContactMailer.contact_email(name, email, body).deliver

Note the `params[:contact][:name]` syntax is called hash syntax. params is the hash.
To understand this we can look at the console that has the app running to monitor
submitted forms. If you submit a form and look at the console you will see
Parameters: {..."contact"=>{"name"=>"test", "email"=>""...} }
These are your query string parameters which are in hash notation. I think it's
a hash within a hash but I'm not sure.

After you have entered this code, save it and go to the contact us page. Enter in
some data and hit submit. The page will just reset to empty fields for now. But...
go to the rails console:

    $ bundle exec rails console
    $ Contact.all

You will see your data saved there!  

At this point the data is being stored to the database. By data we mean the name,
email and comment. The rest of the data like id, created at, etc haven't been
established yet. This line:

    if @contact.save

is the line that does the saving. This line just redirects (reloads) the page:

    redirect_to new_contact_path

--------------------------------------------------------------------------------
### 7. Using Rails Console w/ DB

Lets use the rails console to simulate what the new action from the class
contacts_controller does.

    $ bundle exec rails console
    $ Contact.new

The console will print out the details of the object. You can also use the
`@contact` variable and assign to each of the Contact object's fields.

    $ @contact = Contact.new
    $ @contact
    $ @contact.name = "John Doe"
    $ @contact.email = "friend@friend.com"
    $ @contact.save

The last command actually saves it to our database. Lets look at our first row:

    $ Contact.first

You could also declare a variable and have it set to `Contact.first`

    $ first_contact = Contact.first
    $ first_contact.name      # access the name field
    $ exit                     # or control-d

    **heroku run console**

In your local terminal if you run the following you can sift through the
database there in the same way.

    $ heroku run console

--------------------------------------------------------------------------------
### 8. The Flash Hash Explained

We need to give the user some reassuring feedback when the form has submitted.
We already have this added in our views/layouts/application.html.erb but here
is an explanation

    flash[:success] = 'Message sent.'

This gives the flash a key of "success." and value of "Message sent." in the else:

    flash[:danger] = 'Error occured, message has not been sent.'

And you can get rid of the "notice:" parts that where there. Now go to
views/layouts/application.html.erb and add just before <%= yield %>

    <% flash.each do |key, value| %>
      <%= content_tag :div, value, class: "alert alert-#{key}" %>
    <% end %>

This gives the flash a div. It loops through any flash messages and if it finds
any it puts the key in the class name, and the value as the content of the div.
The reason we choose the class name alert and alert-error / alert-success is
because they come from bootstrap.


--------------------------------------------------------------------------------
### 9. Form Validation

At this point we can input a totally blank form and it will submit it. No good.

Google "active record validations" you will find a page on railsguide which is
a great site. It explains a lot. There are lots of ways but for now we will
use "presence" to our model file.

This is the final state of app/models/contact.rb

    class Contact < ActiveRecord::Base
      validates :name, presence: true
      validates :email, presence: true
    end

Validation in the Contact class could prevent the .save method from working.

2. **Improve View for the Form with Bootstrap**

    This is the final state of views/contacts/new.html.erb

        <div class="row">
            <div class="col-md-4 col-md-offset-4">
                <div class="well">

                    <%= form_for @contact do |f| %>

                        <div class="form-group">
                            <%= f.label :name %>
                            <%= f.text_field :name, class: 'form-control' %>
                        </div>

                        <div class="form-group">
                            <%= f.label :email %>
                            <%= f.email_field :email, class: 'form-control' %>
                        </div>

                        <div class="form-group">
                            <%= f.label :comments %>
                            <%= f.text_area :comments, class: 'form-control' %>
                        </div>

                        <%= f.submit 'Submit', class: 'btn btn-default' %>

                    <% end %>
                </div>
            </div>
        </div>

3. **Adding contacts/new to the Navbar**     

    open up app/views/layouts/application.html.erb which is our, sort of universal
    layout. copy `<li><$= link_to "About", about_path %></li>` and paste as the next
    line. Then change it so it looks like this:

        <li><$= link_to "About", about_path %></li>
        <li><%= link_to "Contact Us", new_contact_path %></li>

    about\_path was generated for us, as was new\_contact\_path, both from routes.rb
    To remind yourself of all of these go to console and type

        $ bundle exec rake routes

    Notice that _path is not show, You need to append with _path

<div class="section jump" id='bcrypt'><!--#brcypt--></div>

# USERS WITH BCRYPT

-------------------------------------------------------------------------------


## Overview

--------------------------------------------------------------------------------
#### 1. The session Object

Each Rails application has a session table which identifies each client and
persists a small amount of data across each of their requests. Rails does this by
assigning a seemingly random string to their cookie and uses it to associate each
request with a particular session.

The cookies themselves are not large enough to contain actual user data and doing
so would be a very insecure way to handle user authenticaion. Hackers would not
have any meaningful way to manipulate the string contained in the cookies unless
they had your secret\_key\_base which would allow them to become any user they want!


--------------------------------------------------------------------------------
#### 2. Sessions and Users

A post request can tell your app what user is signed in:

    class SessionsController < ApplicationController
      ...
      def create
         ...
         session[:current_user_id] = @user.id
         ...


And a get request can query session information:

    class UsersController < ApplicationController


--------------------------------------------------------------------------------
### 1. The Plan

An authentication system is made up of signup, login, logout functionality.
The password\_digest column and has\_secure\_password method are provided by bcrypt
to store passwords securely.

A session begins when a users logs in, and ends when a user logs out.

The current\_user method allow us to access the current user; require_user
redirects to the root of the app if there is no such user.

Before actions act as filters. They call methods before executing controller actions.


--------------------------------------------------------------------------------
### 2. Signup

Store passwords as encrypted strings in the database. This is what the
has\_secure\_password method helps with - it uses the bcrypt algorithm to securely
hash a user's password, which then gets saved in the password_digest column.

Then when a user logs in again, has\_secure\_password will collect the password that
was submitted, hash it with bcrypt, and check if it matches the hash in the database.

1. Users controller - `get '/signup' => 'users#new' - def new @user = User.new end`
2. users#new's `submit => post '/signup' => 'users#create' => redirect_to '/'`
3. User model `has_secure_password `
4. User migration `first_name:string last_name:string email:string password_digest:string`

app/views/users/new.html.erb

     <%= form_for(@user) do |f| %>
        <%= f.text_field :first_name, :placeholder => "First name" %>
        <%= f.text_field :last_name, :placeholder => "Last name" %>
        <%= f.email_field :email, :placeholder => "Email" %>
        <%= f.password_field :password, :placeholder => "Password" %>
        <%= f.submit "Create an account", class: "btn-submit" %>
     <% end %>

Users controller

    def create
      @user = User.new(user_params)
      if @user.save
         session[:user_id] = @user.id
         redirect_to '/'
      else
         redirect_to '/signup'
      end
    end

    private
      def user_params
         params.require(:user).permit(:first_name, :last_name, :email, :password)
      end

Fill in the signup form and submit it, the data is sent to the Rails app via a
POST request. The request hits the User controller's create action. The create
action saves the data, creates a new session, and redirects to the root page.

How is a new session created? Sessions are stored as key/value pairs. In the
create action, the line

    session[:user_id] = @user.id

creates a new session by taking the value @user.id and assigning it to the key
:user_id


--------------------------------------------------------------------------------
### 3. Login

 1. Sessions controller - `get /login => def new end`
 2. sessions#new's `submit => post '/login' => 'sessions#create' => redirect_to '/'`

app/views/sessions/new.html.erb

      <%= f.email_field :email, :placeholder => "Email" %>
      <%= f.password_field :password, :placeholder => "Password" %>
      <%= f.submit "Log in", class: "btn-submit" %>
    <% end %>

In the signup form, we used form_for(@user) do |f| since we had a User model. For
the login form, we don't have a Session model, so we refer to the parameters here:

    <%= form_for(:session, url: login_path) do |f| %>

This refers to the name of the resource and corresponding URL.

sessions#create

    def create
      @user = User.find_by_email(params[:session][:email])
      if @user && @user.authenticate(params[:session][:password])
         session[:user_id] = @user.id
         redirect_to '/'
      else
         redirect_to 'login'
      end
    end

This create action checks whether your email and password exist in the database,
creates a new session, and redirects to the albums page.


--------------------------------------------------------------------------------
### 4. Logout

1. Sessions controller - `delete '/logout' => 'sessions#destroy'`

        def destroy
          session[:user_id] = nil
          redirect_to '/'
        end


--------------------------------------------------------------------------------
### 5. current_user

1. Add def for current_user in ApplicationController

        helper\_method :current\_user

        def current_user
          @current\_user ||= User.find(session[:user\_id]) if session[:user\_id]
        end

    The current_user method determines whether a user is logged in or logged out. It
    does this by checking whether there's a user in the database with a given session
    id. If there is, this means the user is logged in and @current_user will store
    that user; otherwise the user is logged out and @current_user will be nil.

    The line helper\_method :current\_user makes current_user method available in the
    views. By default, all methods defined in Application Controller are already
    available in the controllers.

2. Also add require_user

        def require_user
          redirect\_to '/login' unless current_user
        end

    The require\_user method uses the current\_user method to redirect logged out users
    to the login page.

3. Add the following filter to the top of any controller to restrict access to
    signed in users only.

        before\_action :require\_user, only: [:index, :show]

    The before\_action command calls the require\_user method before running the index
    or show actions.

4. Block out portions or views with this embedded ruby condition:

        <% if current_user %>


--------------------------------------------------------------------------------
### 6. User Roles

There are various ways to have different levels of access to different users. If
you want each user to only have one role - basic, pro, admin, editor, etc - then
you can add a string column to the User db table which displays what role the user
is. If you want Users to be able to have more the one role you might have a
boolean column for each possible role. Lets do the former and have role be either
editor, admin or nil.

After runnning this migration you can add methods to the User model class to query
the db to check for the user's role:

    def editor?
        self.role == 'editor'
    end

    def admin?
        self.role == 'admin'
    end

Then you can create a methods in the application controller which will be used as
a before actions in the various other controllers.

    def require_editor
      redirect_to '/' unless current_user.editor?
    end

    def require_admin
      redirect_to '/' unless current_user.admin?
    end

Now in another controller you can can this before_action:

    before_action :require_editor, only: [:show, :edit]

    before_action :require_admin, only: [:destroy]

Now in the views you can hide links based on these:

    <% if current_user && current_user.editor? %>
      <p class="recipe-edit">
         <%= link_to "Edit Recipe", edit_recipe_path(@recipe.id) %>
      </p>
    <% end %>

    <% if current_user && current_user.admin? %>
      <p class="recipe-delete"><%= link_to "Delete", recipe_path(@recipe), method: "delete" %><p>
    <% end %>

<div class="section jump" id='Devise'><!--#Devise--></div>  

# USERS WITH DEVISE

-------------------------------------------------------------------------------
### 1. Setup Devise

We will add multi-account functionality to the site with a Ruby Gem called Devise.
Add this to Gemfile:

    gem 'devise', '3.4.1'
    ...

Run this terminal commands which will fetch the gem online and install it:

    $ bundle install

Google Devise and go to the Github. We will follow the direction you see there:

    $ bundle exec rails generate devise:install

_REVERSAL:_ You can reverse this generate by replacing "generate" with "destroy."      

The generator will install `config/initializers/devise.rb` which sets all of
Devise's config options. When you are done, you are ready to add Devise to any
of your models using the generator:

    $ bundle exec rails generate devise User    # generates User model
            invoke  active_record
            create    db/migrate/20151012001329_devise_create_users.rb
            create    app/models/user.rb
            invoke    test_unit
            create      test/models/user_test.rb
            create      test/fixtures/users.yml
            insert    app/models/user.rb
             route  devise_for :users  

_REVERSAL:_ You can reverse this generate by replacing "generate" with "destroy."

This will create a model and configure it with default Devise modules and also
configures your routes file to point to the Devise controller. It also created
a migration so lets run it now.

    $ bundle exec rake db:migrate

__WHAT DOES DEVISE GIVE US?__

Devise creates helper functions to use inside your controllers and views. To
restrict a controller to authenticated user, just add this `before_action`:

    before_action :authenticate_user!

If we generated something other than user you would replace the word user above
and below. Here are more helpers:

    user_signed_in?  # test if user is signed in
    current_user
    user_session

--------------------------------------------------------------------------------
### 2. Devise User Views

Devise has it's views packages up inside the Gem and not the app. Since we want
do define the views we use the following generator to give us access to the views
inside our app:

    $ bundle exec rails generate devise:views

        create    app/views/devise/shared/_links.html.erb
        create    app/views/devise/confirmations/new.html.erb
        create    app/views/devise/passwords/edit.html.erb
        create    app/views/devise/passwords/new.html.erb
        create    app/views/devise/registrations/edit.html.erb
        create    app/views/devise/registrations/new.html.erb
        create    app/views/devise/sessions/new.html.erb
        create    app/views/devise/unlocks/new.html.erb
        create    app/views/devise/mailer/confirmation_instructions.html.erb
        create    app/views/devise/mailer/reset_password_instructions.html.erb
        create    app/views/devise/mailer/unlock_instructions.html.erb

If you have more than one Devise model in your app, such as User and
Admin, you will notice that Devise uses the same views for all models. Fortunately,
Devise offers an easy way to customize views. Check their documentation.

Now start the server and go to `/users/sign_up` ... boom. it's there.

_REVERSAL:_ You can reverse this generate by replacing "generate" with "destroy."

--------------------------------------------------------------------------------
### 3. Plan Model: Basic & Pro

__DATABASE ASSOCIATIONS__

We need to have a basic plan and a pro plan contained within a database
model called Plan. Users will obviously have a relation to a Plan, which Rails
calls "associations." Likewise, the basic and pro plans will each have many users.

What we will do it create a model called Plan and then create two tables from
that model; one for basic and one for pro. Each of these tables is basically a
list of all the users that belong to it.

1. Create Plan model

    We need a model file called plan.rb and a migration called `_create_plans.rb`
    We will need a string for name and a decimal for price. Timestamp will be
    automatically.

        $ rails generate model Plan name:string price:decimal

            invoke  active_record
            create    db/migrate/20151012020623_create_plans.rb
            create    app/models/plan.rb
            invoke    test_unit
            create      test/models/plan_test.rb
            create      test/fixtures/plans.yml

    Take a look at the migration file. It's generated perfectly! Take a look at
    models/plan.rb. It's also perfect!

2. Create two Plans from the Model

    If you already ran the Plan.create command, even in a different git branch,
    they are still there. Check with:

        $ bundle exec rails console
        > Plan.all

    If you don't get a readout of the basic and free plans then run:

        > Plan.create(name: 'basic', price: 0)
        > Plan.create(name: 'pro', price: 10)
        > exit

--------------------------------------------------------------------------------
### 4. Add Plan to User

For our site, each user will `belong_to` either a free plan or playing plan.
Likewise, each plan `has_many users`. Now we need to associate the users with the
plans. ow in our Plan class Model:

    class Plan < ActiveRecord::Base
      has_many :users
    end

Notice is users, plural. Now in the User class Model add this to the bottom:

    belongs_to :plan

Notice is plan singular. This is because a user can only belongs_to one plan
and a plan has_many users.

__FOREIGN KEY__

At this point we have two database tables: Plans and Users. We need to associate
those two tables with this concept called a foreign key. We will add another
column to the Users table called plan_id which can be either 'basic' or 'pro.'
Anytime we change something in our database, we generate a migration file:

    $ bundle exec rails g migration AddPlanToUser

Now in the file we just generated `db/migrate/xyz_add_plan_to_user.rb`:

    class AddPlanToUser < ActiveRecord::Migration
      def change
        add_column :users, :plan_id, :integer
      end
    end

This means to add a column to users. The column is plan_id and it's an integer.
We now have our assocations set up! Check out `db/schema.rb` to see out db tables.

Now we need to run this:

    $ bundle exec rake db:migrate

--------------------------------------------------------------------------------
### 5. Partials & More on QSP

We will have a different form for the user to fill out depending on whether
they're signing up for a basic or pro account. We could just make two different
distinct pages for these two forms but this is a good chance to use a feature of
Rails called partials.

Rails partials allow us to have a page display two different ways, using
inserted eRuby from either one file or another. We will have two separate links
on the home page and although they route to the same page, they will pass a
different query string parameter depending on whether they clicked basic or pro.

        <div class="well">
          <h2 class="text-center">Basic Membership</h2>
          <h4>Sign up for free and get basic access to the community.</h4>
          <br/>
          <%= link_to "Sign up with Basic", new_user_registration_path, class: 'btn btn-primary btn-lg btn-block' %>
        </div>
      </div>
      <div class="col-md-6">
        <div class="well">
          <h2 class="text-center">Pro Membership</h2>
          <h4>Sign up for the pro account for $10/month and get access to the community and contact information!</h4>
          <%= link_to "Sign up with Pro", new_user_registration_path, class: 'btn btn-success btn-lg btn-block' %>
        </div>
      </div>

For now the two bottons both take us to the same sign up page. We want CC info in pro.

Also, our sign up link is no longer needed. Go to `views/layouts/application.html.erb `
and remove it.


Now lets make the CC info input form. `app/controllers/pages_controller.rb`:

    def home
      @basic_plan = Plan.find(1)
      @pro_plan = Plan.find(2)
    end

These two instance variables are used on the home page since they are in the
home method action. Plan with a capital P refers to the db table (active record obj).
The find method allows us to pluck out a particular plan with that id. Go into console:

    $ bundle exec rails c
    > Plan.all

Do you see the IDs? 1 is basic and 2 is pro. find() is an active record method.
Now that we have references to the two objects, we can use methods on them.
for example:

    @basic_plan.id    // returns 1
    @basic_plan.name  // returns "basic"

Now head over to `views/pages/home.html.erb`. Where you see this line:

    <%= link_to "Sign up with Basic", new_user_registration_path, class: 'btn btn-primary btn-lg btn-block' %>

Change it to:

    <%= link_to "Sign up with Basic", new_user_registration_path(plan: @basic_plan.id), class: 'btn btn-primary btn-lg btn-block' %>

`(plan: @basic_plan.id)` is the same as `(plan: 1)` but don't do that. Same for pro:

    <%= link_to "Sign up with Pro", new_user_registration_path(plan: @pro_plan.id), class: 'btn btn-success btn-lg btn-block' %>


Now reload the page and look at the URL after clicking each button.
You will see `?plan=1` and `?plan=2`   Just with that, we can catch this info to
change the way the form is presented. The notation we used with the () adds the
query string parameter which is appended to the URL we go to with the link.

Now we have the query string parameters but the form looks the same either way.
What we can do now is add some if statements to the destination page.

In `app/views/devise/registrations/new.html.erb` at the top as the second line
(beween the lines `<div class="row">` and <`div class="col-md-4 col-md-offset-4">`):

    <div class="col-md-6 col-md-offset-3 text-center">
      <% if params[:plan] == '2' %>
         <h1>Pro Account</h1>
         <p>Sign up for the pro account for $10/month and get access to the community and contact information!</p>
      <% else %>
         <h1>Basic Account</h1>
         <p>Sign up for free and get basic access to the community.</p>
      <% end %>
    </div>

--------------------------------------------------------------------------------
### 6. Rails Partials

Now to display the fields of the form for CC input we will use a feature of rails
called partials. We can divide our views out into these partials. Right click on
`app/views/devise/registrations` and create new file called `_basic_form.html.erb.`
The underscore means it's a partial. Now make `_pro_form.html.erb. `

Copy the entire form from `app/views/devise/registrations/new.html.erb` and paste
it into `_basic_form.html.erb`. Now delete it in `new.html.erb` and replace it with

    <%= render "basic_form" %>

No extension or anything. But actually we only want to show that if it is basic.
So instead of the above put this:

    <% if params[:plan] == '2' %>
        <%= render "pro_form" %>
    <% else %>
        <%= render "basic_form" %>
    <% end %>

Now different partials will be shown depending on what link it clicked, but both
partials are the same. For `_pro_plan.html.erb`, copy this:


    <div class="form-group">
        <%= label_tag :card_number, "Credit Card Number" %>
        <%= text_field_tag :card_number, nil, name: nil, class: "form-control" %>
    </div>
    <div class="form-group">
        <%= label_tag :card_code, "Security Code on Card (CVV)" %>
        <%= text_field_tag :card_code, nil, name: nil, class: "form-control" %>
    </div>
    <div class="form-group">
        <%= label_tag :card_month, "Card Expiration" %>
        <%= select_month nil, {add_month_numbers: true}, {name: nil, id: "card_month"}%>
        <%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+15}, {name: nil, id: "card_year"}%>
    </div>

and paste it below the div containing the password confirmation. Now refresh the
page and the CC fields are there. It's a little cluttered though. In new.html.erb,
change the div that contains the "well" to be:

    <div class="col-md-6 col-md-offset-3">

<div class="section jump" id='Stripe'><!--#Stripe--></div>  

# PAYMENTS WITH STRIPE

--------------------------------------------------------------------------------
### 0. Background Info  

Stripe makes it so the web developer doesn't see the actual CC info. This is
great because we don't have to handle security. We will write some JS code that
prevents those fields from sending to our servers. The JS code will reach into
the form and grap those 4 fields and send then to stripe's server. They will then
send back a "Card Token" which is a string. We will then inject this back into
our signup form as a hidden field.

What we will do server-side is write ruby that checks if the user is basic or pro.
If the user is basic, devise gem just adds user to our database. If user is pro,
devise saves user to database, but we also make another call to Stripe's servers
this time we're telling Stripe to go ahead and create a customer and charge their
card.

The inspiration for this approach is comming from a combination of resources.
The stripe documentation itself is good, especially the tut by Larry Ullman.

--------------------------------------------------------------------------------
### 1. Install Stripe and Figaro


Sign up for stripe. Go to the dashboard and make sure you're in test mode.
In the stripe dashboard, click on plans -create your first plan.

    ID    1           ID    2
    Name  Basic       Name  Pro
    Amount 0.0        Amount 10.0  

Now add these to your Gemfile

    # use figaro to hide secret keys
    gem 'figaro'

And because need to hide sensitive information from stripe:

    # use stripe for handling payments
    gem 'stripe'

Also, comment out this because it might conflict

    # gem 'turbolinks'

Install:

    $ bundle install
    $ bundle exec figaro install

Now disable turbolinks from our app. In app/views/layouts/application.html.erb,
remove the following:

    , 'data-turbolinks-track' => true
    , 'data-turbolinks-track' => true

in app/assets/javascripts/application.js remove this line:

    //= require turbolinks

--------------------------------------------------------------------------------
### 2. Communicating With Stripe Servers

create config/initializers/stripe.rb and add:

    Stripe.api_key = ENV["stripe_api_key"]
    STRIPE_PUBLIC_KEY = ENV["stripe_publishable_key"]

In config/application.yml (Put your keys in this file)

    stripe_api_key: sk_test_j4pitqOhsguy2ycyS29yasdf
    stripe_publishable_key: pk_test_opJrdVYavI0jqtE9pjKLasdf
    #
    production:
      stripe_api_key: sk_test_j4pitqOhsguy2ycyS29yasdf
      stripe_publishable_key: pk_test_opJrdVYavI0jqtE9pjKLasdf

--------------------------------------------------------------------------------
### 3. Adding Hidden Fields

in `_basic_form.html.erb` add this below the second line:

    <%= hidden_field_tag 'plan', params[:plan] %>

If you go to the page and inspect it you will see there is an `<input id="plan"
type="hidden" value="1">` that you can't see. It is taking the query string
parameter we send from the button on the home screen in home.html.erb, which uses
variables defined in pages_controller.

Lets do the same for `_pro_form.html.erb`, under the second line:

    <%= hidden_field_tag 'plan', params[:plan] %>

Right now, the HTML generated by both the Basic and Pro buttons have the same id.
If you inspect it you'll see `id="new_user"` In our javascript that will we write
we need to know the difference.

in `_basic_form.html.erb` change the first line to this:

    <%= form_for(resource, as: resource_name, url: registration_path(resource_name), html: {id: 'basic_form'}) do |f| %>

We added, html: {id: 'basic_form'}
In the `_pro_form.html.erb` modify the body of the div containing the button to:

    <%= f.submit "Sign up", class: 'btn btn-success', id: 'form-submit-btn' %>

We added , id: 'form-submit-btn'

    $ git add .
    $ git commit -m "Updated forms for stripe"
    $ git push origin stripe_integration

--------------------------------------------------------------------------------
### 4. Stripe Javascript

Now when submit is hidden, stripe will be sent a hidden field to tell them if it's
basic or pro. Right now when a user hits sumbit for pro, it doesn't send anything
back to our server. Things are sort of on hold pending a reply from stripe.
Our javascript sends the CC info to stripe and we await the reply in the form of
a Card Token which will inject as a hidden field.

We need to import a library into layouts/application.html.erb as the second and
line fourth lines below the `</title> `

    <title>Dev Match</title>
    <%= stylesheet_link_tag 'application', media: 'all' %>
    <%= javascript_include_tag "https://js.stripe.com/v2/", type: 'text/javascript' %>
    <%= javascript_include_tag 'application' %>
    <%= tag :meta, :name => "stripe-key", :content => STRIPE_PUBLIC_KEY %>
    <%= csrf_meta_tags %>

Now create this file app/assets/javascripts/users.js

    $(document).ready(function() {
    Stripe.setPublishableKey($('meta[name="stripe-key"]').attr('content'));
      // Watch for a form submission:
      $("#form-submit-btn").click(function(event) {
        event.preventDefault();
        $('input[type=submit]').prop('disabled', true);
        var error = false;
        var ccNum = $('#card_number').val(),
            cvcNum = $('#card_code').val(),
            expMonth = $('#card_month').val(),
            expYear = $('#card_year').val();
        if (!error) {
          // Get the Stripe token:
          Stripe.createToken({
            number: ccNum,
            cvc: cvcNum,
            exp_month: expMonth,
            exp_year: expYear
          }, stripeResponseHandler);
        }
        return false;
      }); // form submission
      function stripeResponseHandler(status, response) {
        // Get a reference to the form:
        var f = $("#new_user");
        // Get the token from the response:
        var token = response.id;
        // Add the token to the form:
        f.append('<input type="hidden" name="user[stripe_card_token]" value="' + token + '" />');
        // Submit the form:
        f.get(0).submit();
      }
    });


Now we need to create the user accounts on our end.

Create a new folder app/contollers/users and inside it, registrations_controller.rb
Here we will override the default devise stuff. What would happen by default is
devise would create a new user but we need to do a little bit more than that.

    class Users::RegistrationsController < Devise::RegistrationsController
    def create
        super do |resource|
          if params[:plan]
            resource.plan_id = params[:plan]
            if resource.plan_id == 2
              resource.save_with_payment
            else
              resource.save
            end
          end
        end
      end
    end

We are overriding the create method of the RegistrationsController class given to
us by Devise. Now we to make `save_with_payment` in the model file

`models/user.rb` add this:

    def save_with_payment
      if valid?
        customer = Stripe::Customer.create(description: email, plan: plan_id, card: stripe_card_token)
        self.stripe_customer_token = customer.id
        save!
      end
    end

Also, before this definition, add this:

    attr_accessor :stripe_card_token

Now we need to create a column in the database for `stripe_customer_token`.

    $ bundle exec rails generate migration AddStripeCustomerTokenToUsers

Now in the new db/migrate/xyz_add_stripe_customer_token_to_users.rb

    class AddStripeCustomerTokenToUsers < ActiveRecord::Migration
      def change
         add_column :users, :stripe_customer_token, :string
      end
    end

Then run:

    $ bundle exec rake db:migrate

Now whenever we modify Devise like this we need to do the following whitelising
of parameters. in app/controllers/application_controller.rb

    before_filter :configure_permitted_parameters, if: :devise_controller?

    protected
    def configure_permitted_parameters
      devise_parameter_sanitizer.for(:sign_up) { |u| u.permit(:name, :stripe_card_token, :email, :password, :password_confirmation) }
    end

Now we need to tell our application to use this new registrations_controller.
in the router, change the devise_for line to:

    devise_for :users, controllers: { registrations: 'users/registrations' }

Lets just do some minor improvements. Right now when someone signs up they get
a crappy flash notice generated by Devise.

add this to app/assets/stylesheets/custom.css.scss

    .alert-notice {
      color: #8a6d3b;
      background-color: #fcf8e3;
      border-color: #faebcc;
    }

next lets add some subtle improvements to our sign up forms. Right now if the
user clicks on pro the url will have plan=2 at the end and plan=1 for basic.
What happens if the user types plan=3 in the url bar? They will get basic.
We don't want this to be possible.
look at controllers/users/registrations_controller.rb
What we need to add is what rails calls a "before filter"


--------------------------------------------------------------------------------
### 5. Rails Before Filter

If you go to the filters section of the guides.rubyonrails.org you find before filters.
In controllers/users/registrations_controller.rb add this as the first line of class:

    before_filter :select_plan, only: :new

Then as the last thing in the class add this:

    private
    def select_plan
      unless params[:plan] && (params[:plan] == '1' || params[:plan] == '2')
        flash[:notice] = "Please select a membership plan to sign up."
        redirect_to root_url
      end
    end

    $ git add .
    $ git commit -m "Added notice and styles"
    $ git push origin stripe_integration

----Lets push to heroku ---- redo this! -----

    $ git status
    $ git checkout development
    $ git merge stripe_integration
    $ git push origin development
    $ git checkout master
    $ git merge development
    $ git push origin master
    $ git push heroku master
    $ heroku run rake db:migrate
    $ heroku run rails console
    > Plan.create(name: 'basic', price: 0)
    > Plan.create(name: 'pro', price: 10)
    > exit
    $ heroku domains



    ####console commands (Add your keys here after the '=')
    $ heroku config:set stripe_api_key=sk_test_xyz...
    $ heroku config:set stripe_publishable_key=pk_test_xyz...


test with CC# 4242424242424242, any cvv and any exp date


<div class="section jump" id='Paperclip'><!--#Paperclip--></div>  

# IMAGES WITH PAPERCLIP

--------------------------------------------------------------------------------
### 1. ImageMagick & Paperclip setup

The Paperclip gem allows are site to have users upload photos. It requires   
software called ImageMagick to be installed. It may already be installed. Check:

    $ identify
    $ which convert

If that command results ouput you have the software. If not run this:

    $ sudo apt-get install ImageMagick

Next add this to Gemfile:

    # For image uploading
    gem 'paperclip', '4.2.1'

And lastly install the Gemfile

    $ bundle install

--------------------------------------------------------------------------------
### 2. ImageMagick & Paperclip code

**Overview**

To continue the addition of image uploading support we need to:

1. **Add to bottom of app/models/profile.rb**  
    This code comes from paperclip docs

          has_attached_file :avatar, :styles => { :medium => "300x300>", :thumb => "100x100>" },
            :default_url => "http://i1377.photobucket.com/albums/ah75/Jeffrey_Russ/User_No-Frame_zpsf9q2vszh.png"
          validates_attachment_content_type :avatar, :content_type => /\Aimage\/.*\Z/

2. **Create avatar-adding migration file**  
    We want to add the avatar as a db field for each user's profile and paperclip  
    has provided us with a generator to make the migration for it.

          $ bundle exec rails generate paperclip profile avatar
             create db/migrate/20151106151127_add_attachment_avatar_to_profiles.rb

3. **db:migrate**

          $ bundle exec rake db:migrate

--------------------------------------------------------------------------------
### 3. ImageMagick & Paperclip upload

1. **app/views/profiles/_form.html.erb**  

    Add ", :html => { :multipart => true }" to line in app/views/profiles/\_form.html.erb

          <%= form_for @profile, url: user_profile_path, :html => { :multipart => true } do |f| %>

    Add this form field in same file:

          ...
          <div class="form-group">
                <%= f.label :avatar %>
                <%= f.file_field :avatar, class: 'form-control' %>
          </div>
          ...

2. **Whitelist the Avatar Parameter**  

    add ":avatar" to line in app/controllers/profiles\_controller.rb

        ...
        params.require(:profile).permit(:first_name, :last_name, :avatar, :job_title, :phone_number, :contact_email, :description)
        ...

3. **Display Image on Show Page **  

    Add this to the top of app/views/users/show.html.erb:

        <%= image_tag @user.profile.avatar.url %>

    Note that we can use Paperclip here but not on Heroku because Heroku won't  
    store media. You can Use Heroku together with Paperclip on Amazon S3!

<div class="section jump" id='AmazonAWS'><!--#AmazonAWS--></div>    

# AMAZON AWS

-------------------------------------------------------------------------------  
### 4. Add Amazon AWS setup

[READ ME](https://devcenter.heroku.com/articles/paperclip-s3)

You will need to add the following gem in addition to the paperclip gem:

    gem 'aws-sdk'

We need to specify the AWS configuration variables for the Environment.
Add this to config/environments/production.rb and or development.rb

    config.paperclip_defaults = {
      :storage => :s3,
      :s3_credentials => {
         :bucket => ENV['S3_BUCKET_NAME'],
         :access_key_id => ENV['AWS_ACCESS_KEY_ID'],
         :secret_access_key => ENV['AWS_SECRET_ACCESS_KEY']
      }
    }

Set the AWS configuration variables on the Heroku application

    $ heroku config:set S3_BUCKET_NAME=your_bucket_name
    $ heroku config:set AWS_ACCESS_KEY_ID=your_access_key_id
    $ heroku config:set AWS_SECRET_ACCESS_KEY=your_secret_access_key

-------------------------------------------------------------------------------  
### 5. Add Amazon AWS code

Now we need to define the file locations in our app. Add this to whatever model
needs access to the image

    # This method associates the attribute ":avatar" with a file attachment
      has_attached_file :avatar, styles: {
      thumb: '100x100>',
      square: '200x200#',
      medium: '300x300>'
    }

    # Validate the attached image is image/jpg, image/png, etc
    validates_attachment_content_type :avatar, :content_type => /\Aimage\/.*\Z/

The has_attached_file method also accepts a styles hash that specifies the
resize dimensions of the uploaded image. The > and # symbols will tell
ImageMagick how the image will be resized (the > will proportionally reduce the
size of the image).

__Update database__

A database migration is needed to add the avatar attribute on  Profiles in the
database schema. Run the following rails helper method to generate a stub migration.

    $ rails g migration AddAvatarToProfiles

Paperclip comes with the migration helper methods add_attachment and
remove_attachment. They are used to create the columns needed to store image
data in the database. Use them in the AddAvatarToProfiles migration.

    class AddAvatarToProfiles < ActiveRecord::Migration
      def self.up
         add_attachment :profiles, :avatar
      end

      def self.down
         remove_attachment :profiles, :avatar
      end
    end

This migration will create `avatar_file_name`, `avatar_file_size`,
`avatar_content_type`, and `avatar_updated_at` attributes on the  Profiles model.
These attributes will be set automatically when files are uploaded.
Run the migrations with `rake db:migrate` to update your database.

__Upload form__

Images are uploaded to your application before being stored in S3. This allows
your models to perform validations and other processing before being sent to S3.

Add a file input field to the web form that allows users to browse and select
images from their local filesystem.Make sure the form has multipart: true added to it.

    <%= form_for(@profile, multipart: true) do |f| %>
      <div class="field">
         <%= f.label :name %>
         <%= f.text_field :name %>
      </div>
      <div class="field">
         <%= f.label :avatar %>
         <%= f.file_field :avatar %>
      </div>
      <div class="actions">
         <%= f.submit 'Make a profile' %>
         <%= link_to 'Nevermind', profiles_path, class: 'button' %>
      </div>
    <% end %>

When the form is submitted and the backing models are successfully persisted
to the database, the file itself will be uploaded to S3.

__Upload controller__

With Rails 4 we’ll need to specify the permitted params. We’ll permit :name
and :avatar in the params.

    class ProfilesController < ApplicationController
      # Other CRUD actions omitted

      def create
         @profile =  Profiles.new(profile_params)

         if @profile.save
            redirect_to @profile, notice: ' Profiles was successfully created.'
          else
             render action: 'new'
         end
      end

      private

      def profile_params
         params.require(:profile).permit(:avatar, :name)
      end
    end

Large files uploads in single-threaded, non-evented environments (such as
Rails) block your application’s web dynos and can cause request timeouts and
H11, H12 errors. For files larger than 4mb the direct upload method should be
used instead.

__Image display__

Files that have been uploaded with Paperclip are stored in S3. However, metadata
such as the file’s name, location on S3, and last updated timestamp are all stored
in the model’s table in the database.
Access the file’s url through the url method on the model’s file attribute (avatar
in this example).

    profile.avatar.url #=> http://your_bucket_name.s3.amazonaws.com/...

This url can be used directly in the view to display uploaded images.

    <%= image_tag @profile.avatar.url(:square) %>

The url method can take a style (defined earlier in the  Profiles model) to access
a specific processed version of the file.

__Paperclip Demo Application__

As these images are served directly from S3 they don’t interfere with other
requests and allow your page to load quicker than serving directly from your app.
Display the medium sized image by passing :medium to the url method.

    <%= image_tag @profile.avatar.url(:medium) %>

__Deploy__

Once you’ve updated your application to use Paperclip commit the modified files
to git.

    $ git commit -m "Upload profile images via Paperclip"

On deployment to Heroku you will need to migrate your database to support the required file columns.

    $ git push heroku master
    $ heroku run bundle exec rake db:migrate


<div class="section jump" id='Markdown'><!--#Markdown--></div>  

# MARKDOWN SUPPORT

--------------------------------------------------------------------------------
### 1. Install Gems

There are various ways to use plain markdown text in generating HTML pages like
[this](http://webby.rubyforge.org/user-manual/#h3_3)

but this howto uses Redcarpet for md processing and CodeRay for syntax highlighting.

Add these two gems and `$ bundle install` them:

    gem 'redcarpet' # Github's library for Markdown processing
    gem 'coderay'   # syntax highlighting for many languages

--------------------------------------------------------------------------------
### 2. Setup for Redcarpet

Redcarpet needs this file: app/helpers/application_helper.rb:

    module ApplicationHelper
      class CodeRayify < Redcarpet::Render::HTML
        def block_code(code, language)
            CodeRay.scan(code, language).div
        end
      end

      def markdown(text)
        coderayified = CodeRayify.new(:filter_html => true,
                                                :hard_wrap => true)
        options = {
            :fenced_code_blocks => true,
            :no_intra_emphasis => true,
            :autolink => true,
            :strikethrough => true,
            :lax_html_blocks => true,
            :superscript => true
        }
        markdown_to_html = Redcarpet::Markdown.new(coderayified, options)
        markdown_to_html.render(text).html_safe
      end
    end

--------------------------------------------------------------------------------
### 3. Simple Use of Redcarpet

Placing md files in at the root of the project make them available in a
controller like this:

    @file = File.read("file.md")

Or you can put them in a directory called md, for example

    @file = File.read("md/file.md")

The file can have any extension you want or none at all.
Now in views, this will convert markdown to HTML automatically

    <%= markdown(@file) %>

With CodeRay you have to use fenced code blocks and identify the language you're
using instead of indenting to signify a code block.

--------------------------------------------------------------------------------
### 4. Table of Contents with Redcarpet

Redcarpet comes bundled with the ability to generate a table of contents from a
markdown file. For this we will put the following on our controller action:

    text = File.read("md/file.md")
    html_toc = Redcarpet::Markdown.new(Redcarpet::Render::HTML_TOC)
    markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML.new(:with_toc_data => true))
    @toc  = html_toc.render(text).html_safe
    @html = markdown.render(text).html_safe

Here we have everything fully rendered in the controller, ready to be used in erb

    <div>
      <%= @html %>
    </div>   
    <div>
      <%= @toc %>
    </div>


<hr>
<a href='http://www.jeffruss.com' style='color:#FFFFEE'>
<small>© Copyright 2016 Jeffrey Russ</small><br><br><br>
</a>
